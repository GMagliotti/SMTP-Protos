#include "client_monitor.h"

/* Request format: 14 bytes
 0      7 8     15 16    23 24    31 32    39 40    47 48    55 56    63
+--------+--------+--------+--------+--------+--------+--------+--------+
|                 |        |                 |                          |
|    signature    |  vers  |    request_id   |           auth           |
|                 |        |                 |                          |
+--------+--------+--------+--------+--------+--------+--------+--------+
|                                            |        |                 |
|                    auth                    |  cmd   |                 |
|                                            |        |                 |
+--------+--------+--------+--------+--------+--------+--------+--------+
*/

void
printBytesRecieved(uint8_t* buffer, ssize_t numBytes)
{
	printf("Received: ");
	for (int i = 0; i < numBytes; i++) {
		printf("buff[%d]=%02x ", i, buffer[i]);
	}
	printf("\n");
	// now print them like in an array and bing hex values: { 0x00, 0x00, 0x00, }
	printf("Received: { ");
	for (int i = 0; i < numBytes; i++) {
		printf("0x%02x, ", buffer[i]);
	}
	printf("}\n");
}

int
sockAddrsEqual(const struct sockaddr* addr1, const struct sockaddr* addr2)
{
	if (addr1 == NULL || addr2 == NULL)
		return addr1 == addr2;
	else if (addr1->sa_family != addr2->sa_family)
		return 0;
	else if (addr1->sa_family == AF_INET) {
		struct sockaddr_in* ipv4Addr1 = (struct sockaddr_in*)addr1;
		struct sockaddr_in* ipv4Addr2 = (struct sockaddr_in*)addr2;
		return ipv4Addr1->sin_addr.s_addr == ipv4Addr2->sin_addr.s_addr && ipv4Addr1->sin_port == ipv4Addr2->sin_port;
	} else if (addr1->sa_family == AF_INET6) {
		struct sockaddr_in6* ipv6Addr1 = (struct sockaddr_in6*)addr1;
		struct sockaddr_in6* ipv6Addr2 = (struct sockaddr_in6*)addr2;
		return memcmp(&ipv6Addr1->sin6_addr, &ipv6Addr2->sin6_addr, sizeof(struct in6_addr)) == 0 &&
		       ipv6Addr1->sin6_port == ipv6Addr2->sin6_port;
	} else
		return 0;
}

int
udpClientSocket(const char* host, const char* service, struct addrinfo** servAddr)
{
	// Pedimos solamente para UDP, pero puede ser IPv4 o IPv6
	struct addrinfo addrCriteria;
	memset(&addrCriteria, 0, sizeof(addrCriteria));
	addrCriteria.ai_family = AF_UNSPEC;      // Any address family
	addrCriteria.ai_socktype = SOCK_DGRAM;   // Only datagram sockets
	addrCriteria.ai_protocol = IPPROTO_UDP;  // Only UDP protocol

	// Tomamos la primera de la lista
	int rtnVal = getaddrinfo(host, service, &addrCriteria, servAddr);
	if (rtnVal != 0) {
		perror("getaddrinfo() failed");
		return -1;
	}

	// Socket cliente UDP
	return socket(
	    (*servAddr)->ai_family, (*servAddr)->ai_socktype, (*servAddr)->ai_protocol);  // Socket descriptor for client
}

/*
struct protocol_request {
    // protocol data
    uint16_t signature;
    uint8_t version;
    uint16_t request_id;  // generated by the client
    uint8_t token[8];     // 8 unsigned big-endian bytes
    uint8_t command;
}
*/

void
prepareBuffer(uint8_t* buffer, uint16_t request_id, uint8_t cmd)
{
	// we want to convert the values to Network Byte Order using netdb.h

	uint16_t signature = htons((uint16_t)SIGNATURE);
	request_id = htons(request_id);

	buffer[0] = (signature >> 8) & 0xff;
	buffer[1] = signature & 0xff;
	buffer[2] = VERSION;
	buffer[3] = (request_id >> 8) & 0xff;
	buffer[4] = request_id & 0xff;
	buffer[5] = (TOKEN >> 56) & 0xff;
	buffer[6] = (TOKEN >> 48) & 0xff;
	buffer[7] = (TOKEN >> 40) & 0xff;
	buffer[8] = (TOKEN >> 32) & 0xff;
	buffer[9] = (TOKEN >> 24) & 0xff;
	buffer[10] = (TOKEN >> 16) & 0xff;
	buffer[11] = (TOKEN >> 8) & 0xff;
	buffer[12] = TOKEN & 0xff;
	buffer[13] = cmd;
}
/*
enum commands
{
    HIST_C = 0x00,
    CONC_C,
    BYTES_T,
    TRANS_S,
    TRANS_ON,
    TRANS_OFF
};
static const char* commands_str[] = { "HIST", "CONC", "BYTES", "STATUS", "T_ON", "T_OFF" };
 */
int
commandExists(char* command, int* commandReference)
{
	for (int i = 0; i < 6; i++) {
		if (strcmp(command, commands_str[i]) == 0) {
			*commandReference = i;
			return 1;
		}
	}
	return 0;
}

int
argsQuantityOk(int command, int argc)
{
	if (command < 0 || argc <= 1)
		return 0;
	return 1;
}

uint16_t
request_id_generator(void)
{
	static uint16_t request_id = 0;
	return request_id++;
}

int
main(int argc, char* argv[])
{
	// we need to implement a client application for the monitor protocol
	/*
	    Client works like this:
	    1. Validate the command line arguments
	    2. Prepare the buffer
	    3. Send the buffer
	    4. Wait for the response
	    5. Validate the response
	    6. If the response never arrives, the client should timeout
	    7. If the response is invalid, the client should print an error message
	    8. If the response is valid, the client should print the response data
	*/

	if (argc <= 3 || strcmp("-h", argv[3]) == 0) {
		fprintf(stderr,
		        "Usage: %s [HOST] [PORT] [OPTION]\n"
		        "\n use '-' to specify default values for [HOST] and [PORT]\n"
		        "\n"
		        "   -h                                        Prints help and finishes.\n"
		        "   HIST                                      Request historical conections.\n"
		        "   CONC                                      Request simultaneous conections.\n"
		        "   BYTES                                     Request ammount of transfered bytes.\n"
		        "   STATUS     	                              Request information about transformations.\n"
		        "   T_ON                                      Request to turn on transformations.\n"
		        "   T_OFF                                     Request to turn off transformations.\n"
		        "\n",
		        argv[0]);
		return 0;
	}

	const char* host = argv[1];
	const char* port = argv[2];

	if (host[0] == '-')
		host = DEFAULT_HOST;
	if (port[0] == '-')
		port = DEFAULT_PORT;

	char* command = argv[3];
	int commandReference;

	if (!commandExists(command, &commandReference)) {
		printf("%s: is not a valid command\n", command);
		return -1;
	}

	if (!argsQuantityOk(commandReference, argc)) {
		printf("%s: few arguments\n", command);
		return -1;
	}

	struct addrinfo* servAddr;

	uint8_t buffer[REQUEST_SIZE] = { 0 };
	prepareBuffer(buffer, request_id_generator(), commandReference);

	int sock = udpClientSocket(host, port, &servAddr);

	printf("Sending command %s to %s:%s\n", commands_str[commandReference], host, port);
	ssize_t numBytes = sendto(sock, buffer, REQUEST_SIZE, 0, servAddr->ai_addr, servAddr->ai_addrlen);

	if (numBytes < 0) {
		perror("sendto() failed");
		return -1;
	}

	if (numBytes < 0) {
		perror("sendto() failed");
	} else if (numBytes != REQUEST_SIZE) {
		perror("sendto() error, sent unexpected number of bytes");
	}

	// Guardamos la direccion/puerto de respuesta para verificar que coincida con el servidor
	struct sockaddr_storage fromAddr;  // Source address of server
	socklen_t fromAddrLen = sizeof(fromAddr);
	uint8_t rec_buffer[REQUEST_SIZE + 1];

	// Establecemos un timeout de 5 segundos para la respuesta
	struct timeval tv;  // Timeout for recvfrom(). It is in library sys/time.h
	tv.tv_sec = 60 * 10;
	tv.tv_usec = 0;
	if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
		perror("Error setting timeout");
	}

	numBytes = recvfrom(sock, rec_buffer, REQUEST_SIZE, 0, (struct sockaddr*)&fromAddr, &fromAddrLen);
	if (numBytes < 0) {
		perror("recvfrom() failed");
	} else {
		if (numBytes != REQUEST_SIZE)
			perror("recvfrom() error, received unexpected number of bytes");

		// "Autenticamos" la respuesta
		if (!sockAddrsEqual(servAddr->ai_addr, (struct sockaddr*)&fromAddr))
			perror("recvfrom() error, received a packet from an unknown source");

		rec_buffer[numBytes] = '\0';
		printBytesRecieved(rec_buffer, numBytes);
	}

	freeaddrinfo(servAddr);
	close(sock);

	return 0;
}
